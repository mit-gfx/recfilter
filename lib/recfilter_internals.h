#ifndef _RECURSIVE_FILTER_INTERNALS_H_
#define _RECURSIVE_FILTER_INTERNALS_H_

#include <vector>
#include <string>
#include <Halide.h>

/** Info about scans in a particular dimension */
struct FilterInfo {
    int                  filter_order;  ///< order of recursive filter in a given dimension
    int                  filter_dim;    ///< dimension id
    int                  num_scans;     ///< number of scans in the dimension that must be tiled
    Halide::Expr         image_width;   ///< image width in this dimension
    Halide::Var          var;           ///< variable that represents this dimension
    Halide::RDom         rdom;          ///< RDom update domain of each scan
    std::vector<bool>    scan_causal;   ///< causal or anticausal flag for each scan
    std::vector<int>     scan_id;       ///< scan or update definition id of each scan
};

// ----------------------------------------------------------------------------

enum FunctionTag {
    INLINE  = 0x000, ///< function to be removed by inlining
    INTER   = 0x010, ///< filter over tail elements across tiles (single 1D scan)
    INTRA_N = 0x020, ///< filter within tile (multiple scans in multiple dimensions)
    INTRA_1 = 0x040, ///< filter within tile (single scan in one dimension)
    REINDEX = 0x100, ///< function that reindexes a subset of another function to write to global mem
};

enum VariableTag {
    INVALID = 0x0000, ///< invalid var
    FULL    = 0x0010, ///< full dimension before tiling
    INNER   = 0x0020, ///< inner dimension after tiling
    OUTER   = 0x0040, ///< outer dimension after tiling
    TAIL    = 0x0080, ///< if dimension is at lower granularity (only for inner dimensions)
    SCAN    = 0x0100, ///< if dimension is a scan
    __1     = 0x0001, ///< first variable with one of the above tags
    __2     = 0x0002, ///< second variable with one of the above tags
    __3     = 0x0004, ///< third variable with one of the above tags
    __4     = 0x0008, ///< fourth variable with one of the above tags
    SPLIT   = 0x1000, ///< any variable generated by split scheduling operations
};


/** @name Logical operations for scheduling tags */
// {@
VarTag      operator |(const VarTag &a, const VarTag &b);
VarTag      operator &(const VarTag &a, const VarTag &b);
VariableTag operator |(const VariableTag &a, const VariableTag &b);
VariableTag operator &(const VariableTag &a, const VariableTag &b);

bool operator==(const FuncTag &a, const FuncTag &b);
bool operator==(const VarTag  &a, const VarTag &b);
bool operator!=(const FuncTag &a, const FuncTag &b);
bool operator!=(const VarTag  &a, const VarTag &b);
bool operator==(const FuncTag &a, const FunctionTag &b);
bool operator==(const VarTag  &a, const VariableTag &b);
// @}


/** @name Utils to print scheduling tags */
// {@
std::ostream &operator<<(std::ostream &s, const FunctionTag &f);
std::ostream &operator<<(std::ostream &s, const VariableTag &v);
std::ostream &operator<<(std::ostream &s, const FuncTag &f);
std::ostream &operator<<(std::ostream &s, const VarTag &v);
// @}


/** Scheduling tags for Functions */
class FuncTag {
public:
    FuncTag(void)                 : tag(INLINE){}
    FuncTag(const FuncTag     &t) : tag(t.tag) {}
    FuncTag(const FunctionTag &t) : tag(t)     {}
    FuncTag& operator=(const FuncTag     &t) { tag=t.tag; return *this; }
    FuncTag& operator=(const FunctionTag &t) { tag=t;     return *this; }
    int as_integer(void) const { return static_cast<int>(tag); }

private:
    FunctionTag tag;
};


/** Scheduling tags for Function dimensions */
class VarTag {
public:
    VarTag(void)                 : tag(INVALID){}
    VarTag(const VarTag      &t) : tag(t.tag) {}
    VarTag(const VariableTag &t) : tag(t)     {}
    VarTag(const VarTag      &t, int i) : VarTag(t.tag,i) {}
    VarTag(const VariableTag &t, int i) {
        switch(i) {
            case 0: tag = VarTag(t | __1).tag; break;
            case 1: tag = VarTag(t | __2).tag; break;
            case 2: tag = VarTag(t | __3).tag; break;
            case 3: tag = VarTag(t | __4).tag; break;
            default: std::cerr << "Cannot convert integer to VarTag count" << std::endl; assert(false);
        }
    }
    VarTag(int i) : tag(static_cast<VariableTag>(i)) {}

    VarTag& operator=(const VarTag      &t) { tag=t.tag; return *this; }
    VarTag& operator=(const VariableTag &t) { tag=t;     return *this; }

    int as_integer  (void) const { return static_cast<int>(tag); }
    VarTag split_var(void) const { return VarTag(tag|SPLIT);     }

    int check(const VariableTag &t) const { return (as_integer() & VarTag(t).as_integer()); }

    int count(void) const {
        VariableTag count = static_cast<VariableTag>(static_cast<int>(tag) & 0x0000000f);
        int count_int;
        switch(count) {
            case __1: count_int = 0; break;
            case __2: count_int = 1; break;
            case __3: count_int = 2; break;
            case __4: count_int = 3; break;
            default: std::cerr << "VarTag does not have a count" << std::endl; assert(false);
        }
        return count_int;
    }
    void decrement_count(void) {
        switch (get_count()) {
            case __2: tag = get_tag() | __1; break;
            case __3: tag = get_tag() | __2; break;
            case __4: tag = get_tag() | __3; break;
            default: std::cerr << "Cannot decrement count of VarTag" << std::endl; assert(false);
        }
    }
    void increment_count(void) {
        switch (get_count()) {
            case __1: tag = get_tag() | __2; break;
            case __2: tag = get_tag() | __3; break;
            case __3: tag = get_tag() | __4; break;
            default: std::cerr << "Cannot increment count of VarTag" << std::endl; assert(false);
        }
    }

private:
    VariableTag tag;

    VariableTag get_tag  (void) const { return static_cast<VariableTag>(static_cast<int>(tag) & 0xfffffff0); }
    VariableTag get_count(void) const { return static_cast<VariableTag>(static_cast<int>(tag) & 0x0000000f); }
};

// ----------------------------------------------------------------------------

/** Recursive filter function with scheduling interface */
class RecFilterFunc {
public:
    /** Halide function */
    Halide::Internal::Function func;

    /** Category tag for the function */
    FuncTag func_category;

    /** Category tags for all the pure def vars  */
    std::map<std::string, VarTag> pure_var_category;

    /** Category tags for all the vars in all the update defs */
    std::vector<std::map<std::string,VarTag> >  update_var_category;

    /** Name of a function that calls this function; set if this function
     * has the REINDEX_FOR_READ tag set */
    std::string caller_func;

    /** Name of a function that this function calls; set if this function
     * has the REINDEX_FOR_WRITE tag set */
    std::string callee_func;

    /** Function schedule as valid Halide code; first element is pure
     * def schedule, subsequent entries are update def schedule */
    std::map<int, std::vector<std::string> >  schedule;
};

// ----------------------------------------------------------------------------

/** Data members of the recursive filter */
struct RecFilterContents {
    /** Smart pointer */
    mutable Halide::Internal::RefCount ref_count;

    /** Flag to indicate if the filter has been tiled  */
    bool tiled;

    /** Flag to indicate if the filter has been finalized, which performs platform specific optimizations */
    bool finalized;

    /** Name of recursive filter as well as function that contains the
     * definition of the filter  */
    std::string name;

    /** Info about all the scans in the recursive filter */
    std::vector<FilterInfo> filter_info;

    /** List of functions along with their names and their schedules */
    std::map<std::string, RecFilterFunc> func;

    /** Image border expression */
    Halide::Expr border_expr;

    /** Feed forward coeffs, only one for each scan */
    Halide::Image<float> feedfwd_coeff;

    /** Feedback coeffs (num_scans x max_order) order j-th coeff of i-th scan is (i+1,j) */
    Halide::Image<float> feedback_coeff;
};

#endif // _RECURSIVE_FILTER_INTERNALS_H_
