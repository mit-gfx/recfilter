<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>RecFilter: RecFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RecFilter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_rec_filter.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">RecFilter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Recursive filter class.  
 <a href="class_rec_filter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="recfilter_8h_source.html">recfilter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d81c3ca6573aa168612ea034b0ff1ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a2d81c3ca6573aa168612ea034b0ff1ce">RecFilter</a> (std::string <a class="el" href="class_rec_filter.html#a37a0864233f2ff9e93cdaa4062d2956a">name</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a2d81c3ca6573aa168612ea034b0ff1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#a2d81c3ca6573aa168612ea034b0ff1ce">More...</a><br/></td></tr>
<tr class="separator:a2d81c3ca6573aa168612ea034b0ff1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77471b4e462a755d32e5f7e5ea0fa677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter.html">RecFilter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a77471b4e462a755d32e5f7e5ea0fa677">operator=</a> (const <a class="el" href="class_rec_filter.html">RecFilter</a> &amp;r)</td></tr>
<tr class="memdesc:a77471b4e462a755d32e5f7e5ea0fa677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard assignment operator.  <a href="#a77471b4e462a755d32e5f7e5ea0fa677">More...</a><br/></td></tr>
<tr class="separator:a77471b4e462a755d32e5f7e5ea0fa677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a0864233f2ff9e93cdaa4062d2956a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a37a0864233f2ff9e93cdaa4062d2956a">name</a> (void) const </td></tr>
<tr class="memdesc:a37a0864233f2ff9e93cdaa4062d2956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the filter.  <a href="#a37a0864233f2ff9e93cdaa4062d2956a">More...</a><br/></td></tr>
<tr class="separator:a37a0864233f2ff9e93cdaa4062d2956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1fba24eaeb92a5411292858276da0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#afd1fba24eaeb92a5411292858276da0b">define</a> (std::vector&lt; <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> &gt; pure_args, std::vector&lt; Halide::Expr &gt; pure_def)</td></tr>
<tr class="memdesc:afd1fba24eaeb92a5411292858276da0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pure definition to the recursive filter.  <a href="#afd1fba24eaeb92a5411292858276da0b">More...</a><br/></td></tr>
<tr class="separator:afd1fba24eaeb92a5411292858276da0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5d4af2950d333846fb7ec0802ac63"><td class="memItemLeft" align="right" valign="top">Halide::Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a7ef5d4af2950d333846fb7ec0802ac63">as_func</a> (void)</td></tr>
<tr class="memdesc:a7ef5d4af2950d333846fb7ec0802ac63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the recfilter as a Halide::Func; this returns the function that holds the final result of this filter; useful for extracting the result of this function to use as input to other Halide Func.  <a href="#a7ef5d4af2950d333846fb7ec0802ac63">More...</a><br/></td></tr>
<tr class="separator:a7ef5d4af2950d333846fb7ec0802ac63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd754d0ab969e2a56cd2d6d27c0b6e4"><td class="memItemLeft" align="right" valign="top">Halide::Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a6bd754d0ab969e2a56cd2d6d27c0b6e4">func</a> (std::string func_name)</td></tr>
<tr class="memdesc:a6bd754d0ab969e2a56cd2d6d27c0b6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the constituent function by name, useful for debugging:  <a href="#a6bd754d0ab969e2a56cd2d6d27c0b6e4">More...</a><br/></td></tr>
<tr class="separator:a6bd754d0ab969e2a56cd2d6d27c0b6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recursive filter initialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions allow functional programming like syntax to initialize a recursive filter</p>
<div class="fragment"><div class="line">R(x)       = some_expression_involving_x         <span class="comment">// 1D filter</span></div>
<div class="line">R(x,y)     = some_expression_involving_x_y       <span class="comment">// 2D filter</span></div>
<div class="line">R(x,y,z)   = some_expression_involving_x_y_z     <span class="comment">// 3D filter</span></div>
<div class="line">R({x,y..}) = some_expression_for_involving_x_y.. <span class="comment">// nD filter</span></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a69bb99a78cf5fa4dfb7fb7ee5900dbbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a69bb99a78cf5fa4dfb7fb7ee5900dbbc">operator()</a> (<a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> x)</td></tr>
<tr class="separator:a69bb99a78cf5fa4dfb7fb7ee5900dbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95eebe7bfb0e8af0b5eef9bd536e2249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a95eebe7bfb0e8af0b5eef9bd536e2249">operator()</a> (<a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> x, <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> y)</td></tr>
<tr class="separator:a95eebe7bfb0e8af0b5eef9bd536e2249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c20deae5c7f60d664550b70618e9360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a4c20deae5c7f60d664550b70618e9360">operator()</a> (<a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> x, <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> y, <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> z)</td></tr>
<tr class="separator:a4c20deae5c7f60d664550b70618e9360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0842626edd0ba9035be35e04a0afa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a7f0842626edd0ba9035be35e04a0afa6">operator()</a> (std::vector&lt; <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> &gt; x)</td></tr>
<tr class="separator:a7f0842626edd0ba9035be35e04a0afa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Recursive filter result expression</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions return an expression that represents the final result of the filter</p>
<div class="fragment"><div class="line">R(x)       <span class="comment">// pixel x for a 1D filter</span></div>
<div class="line">R(x,y)     <span class="comment">// pixel (x,y) for a 1D filter</span></div>
<div class="line">R(x,y,z)   <span class="comment">// pixel (x,y,z) for a 1D filter</span></div>
<div class="line">R({x,y..}) <span class="comment">// pixel (x,y..) for a nD filter</span></div>
</div><!-- fragment --> </div></td></tr>
<tr class="memitem:a37b98112eff6cc3c93b2f1004d9d1986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a37b98112eff6cc3c93b2f1004d9d1986">operator()</a> (Halide::Var x)</td></tr>
<tr class="separator:a37b98112eff6cc3c93b2f1004d9d1986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f59f79aa1091a29ee9f67baed52212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a96f59f79aa1091a29ee9f67baed52212">operator()</a> (Halide::Var x, Halide::Var y)</td></tr>
<tr class="separator:a96f59f79aa1091a29ee9f67baed52212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba6e6d46148edefd02e33568963aa46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a8ba6e6d46148edefd02e33568963aa46">operator()</a> (Halide::Var x, Halide::Var y, Halide::Var z)</td></tr>
<tr class="separator:a8ba6e6d46148edefd02e33568963aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aae2992f981e0553a9f8be1a7e69668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a5aae2992f981e0553a9f8be1a7e69668">operator()</a> (std::vector&lt; Halide::Var &gt; x)</td></tr>
<tr class="separator:a5aae2992f981e0553a9f8be1a7e69668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00b8eac289bbc5adf5386b7f74590ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ae00b8eac289bbc5adf5386b7f74590ee">operator()</a> (Halide::Expr x)</td></tr>
<tr class="separator:ae00b8eac289bbc5adf5386b7f74590ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59313113935d135a33c950f2ed08ada0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a59313113935d135a33c950f2ed08ada0">operator()</a> (Halide::Expr x, Halide::Expr y)</td></tr>
<tr class="separator:a59313113935d135a33c950f2ed08ada0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fe922d57eb70495f5612f4041d5926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ad1fe922d57eb70495f5612f4041d5926">operator()</a> (Halide::Expr x, Halide::Expr y, Halide::Expr z)</td></tr>
<tr class="separator:ad1fe922d57eb70495f5612f4041d5926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3b4e91582270d3ab01e3fdbf1dbba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#afa3b4e91582270d3ab01e3fdbf1dbba8">operator()</a> (std::vector&lt; Halide::Expr &gt; x)</td></tr>
<tr class="separator:afa3b4e91582270d3ab01e3fdbf1dbba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compile and run</div></td></tr>
<tr class="memitem:a4d3304a7c3cde75cd9816cc8b6b09775"><td class="memItemLeft" align="right" valign="top">Halide::Target&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a4d3304a7c3cde75cd9816cc8b6b09775">target</a> (void)</td></tr>
<tr class="memdesc:a4d3304a7c3cde75cd9816cc8b6b09775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the compilation target, inferred from HL_JIT_TARGET.  <a href="#a4d3304a7c3cde75cd9816cc8b6b09775">More...</a><br/></td></tr>
<tr class="separator:a4d3304a7c3cde75cd9816cc8b6b09775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d39bba6665e25f820b0cffdaa33512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a02d39bba6665e25f820b0cffdaa33512">apply_bounds</a> (void)</td></tr>
<tr class="memdesc:a02d39bba6665e25f820b0cffdaa33512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply output domains bounds; this is performed implicitly for tiled filters, but it must be called by the application for non-tiled filters.  <a href="#a02d39bba6665e25f820b0cffdaa33512">More...</a><br/></td></tr>
<tr class="separator:a02d39bba6665e25f820b0cffdaa33512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3890b22a739fffd4bb2c6600e62cf9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a3890b22a739fffd4bb2c6600e62cf9b0">compile_jit</a> (std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a3890b22a739fffd4bb2c6600e62cf9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger JIT compilation for specified hardware-platform target; dumps the generated codegen in human readable HTML format if filename is specified.  <a href="#a3890b22a739fffd4bb2c6600e62cf9b0">More...</a><br/></td></tr>
<tr class="separator:a3890b22a739fffd4bb2c6600e62cf9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b5e225e29c07bd5bd929a316d595db"><td class="memItemLeft" align="right" valign="top">Halide::Realization&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ab3b5e225e29c07bd5bd929a316d595db">realize</a> (void)</td></tr>
<tr class="memdesc:ab3b5e225e29c07bd5bd929a316d595db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the filter.  <a href="#ab3b5e225e29c07bd5bd929a316d595db">More...</a><br/></td></tr>
<tr class="separator:ab3b5e225e29c07bd5bd929a316d595db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966478f0506b8b5fab094069b1c9ff74"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a966478f0506b8b5fab094069b1c9ff74">profile</a> (int iterations)</td></tr>
<tr class="memdesc:a966478f0506b8b5fab094069b1c9ff74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profile the filter.  <a href="#a966478f0506b8b5fab094069b1c9ff74">More...</a><br/></td></tr>
<tr class="separator:a966478f0506b8b5fab094069b1c9ff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Routines to add filters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Add a causal or anticausal scan to the recursive filter with given feedback and feed forward coefficients</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>filter dimension </td></tr>
    <tr><td class="paramname">coeff</td><td>1 feedforward and n feedback coeffs (n = filter order)</td></tr>
  </table>
  </dd>
</dl>
<p>Preconditions:</p>
<ul>
<li>first argument must of of the form +x, -x or x where x is a <a class="el" href="class_rec_filter_dim.html" title="Filter dimension with variable name and width of image in the dimension. ">RecFilterDim</a> object </li>
</ul>
</div></td></tr>
<tr class="memitem:a5c2f413766eca7830f430d37ca49028b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a5c2f413766eca7830f430d37ca49028b">add_filter</a> (<a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> x, std::vector&lt; float &gt; coeff)</td></tr>
<tr class="separator:a5c2f413766eca7830f430d37ca49028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b48679f260a209a75bb2e215a44c48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a34b48679f260a209a75bb2e215a44c48">add_filter</a> (<a class="el" href="class_rec_filter_dim_and_causality.html">RecFilterDimAndCausality</a> x, std::vector&lt; float &gt; coeff)</td></tr>
<tr class="separator:a34b48679f260a209a75bb2e215a44c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Image boundary conditions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Clamp image border to the last pixel in all boundaries, default border is 0 </p>
</div></td></tr>
<tr class="memitem:a743a239a5c3668859936751b029bc468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a743a239a5c3668859936751b029bc468">set_clamped_image_border</a> (void)</td></tr>
<tr class="separator:a743a239a5c3668859936751b029bc468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tiling routines</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Tile a list of dimensions into their respective tile widths specified as variable-tile width pairs.</p>
<p>Preconditions:</p>
<ul>
<li>dimension with specified variable name must exist</li>
<li>tile width must be a multiple of image width for each dimension </li>
</ul>
</div></td></tr>
<tr class="memitem:aeacd059770a9578ad0242f5072450cc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#aeacd059770a9578ad0242f5072450cc4">split_all_dimensions</a> (int tx)</td></tr>
<tr class="separator:aeacd059770a9578ad0242f5072450cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e6144a8ca33c281ddb9b1afedc57e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a9e4e6144a8ca33c281ddb9b1afedc57e">split</a> (<a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> x, int tx)</td></tr>
<tr class="separator:a9e4e6144a8ca33c281ddb9b1afedc57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a0ae3a383f221db2b20bb6c5055edd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a26a0ae3a383f221db2b20bb6c5055edd">split</a> (<a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> x, int tx, <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> y, int ty)</td></tr>
<tr class="separator:a26a0ae3a383f221db2b20bb6c5055edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f92df46549b11e387cfa2e19cdb1da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a3f92df46549b11e387cfa2e19cdb1da2">split</a> (<a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> x, int tx, <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> y, int ty, <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> z, int tz)</td></tr>
<tr class="separator:a3f92df46549b11e387cfa2e19cdb1da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6a9ed94a44eb190ec8f8fcb989f5c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a7f6a9ed94a44eb190ec8f8fcb989f5c9">split</a> (std::map&lt; std::string, int &gt; dims)</td></tr>
<tr class="separator:a7f6a9ed94a44eb190ec8f8fcb989f5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cascading API</div></td></tr>
<tr class="memitem:a014f6e2309aee9827237495bd977cc78"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_rec_filter.html">RecFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a014f6e2309aee9827237495bd977cc78">cascade</a> (std::vector&lt; int &gt; a, std::vector&lt; int &gt; b)</td></tr>
<tr class="memdesc:a014f6e2309aee9827237495bd977cc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cascade the filter to produce multiple filters using list of list of scans and producing a list of recursive filters each ccomputes the corresponding list of scans in an overlapped fashion.  <a href="#a014f6e2309aee9827237495bd977cc78">More...</a><br/></td></tr>
<tr class="separator:a014f6e2309aee9827237495bd977cc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be1a6cfe13f5792d68cb16b13406f5d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_rec_filter.html">RecFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a4be1a6cfe13f5792d68cb16b13406f5d">cascade</a> (std::vector&lt; std::vector&lt; int &gt; &gt; scan)</td></tr>
<tr class="memdesc:a4be1a6cfe13f5792d68cb16b13406f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cascade the filter to produce multiple filters using list of list of scans and producing a list of recursive filters each ccomputes the corresponding list of scans in an overlapped fashion.  <a href="#a4be1a6cfe13f5792d68cb16b13406f5d">More...</a><br/></td></tr>
<tr class="separator:a4be1a6cfe13f5792d68cb16b13406f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c96660f146b3cea43385a343dc3408"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_rec_filter.html">RecFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a40c96660f146b3cea43385a343dc3408">cascade_by_causality</a> (void)</td></tr>
<tr class="memdesc:a40c96660f146b3cea43385a343dc3408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computing all causal scans in all dimensions in an overlapped fashion and all anticausal scans in an overlapped fashion and cascade the two groups.  <a href="#a40c96660f146b3cea43385a343dc3408">More...</a><br/></td></tr>
<tr class="separator:a40c96660f146b3cea43385a343dc3408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ee44f54ea0788f74a1ce839701bc17"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_rec_filter.html">RecFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ac0ee44f54ea0788f74a1ce839701bc17">cascade_by_dimension</a> (void)</td></tr>
<tr class="memdesc:ac0ee44f54ea0788f74a1ce839701bc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all scans in the same dimension in an overlapped fashion and cascade different dimensions.  <a href="#ac0ee44f54ea0788f74a1ce839701bc17">More...</a><br/></td></tr>
<tr class="separator:ac0ee44f54ea0788f74a1ce839701bc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8824833e1d3cc3f5badaf1ff7f4f98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter.html">RecFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a4b8824833e1d3cc3f5badaf1ff7f4f98">overlap_to_higher_order_filter</a> (<a class="el" href="class_rec_filter.html">RecFilter</a> fA, std::string <a class="el" href="class_rec_filter.html#a37a0864233f2ff9e93cdaa4062d2956a">name</a>=&quot;O&quot;)</td></tr>
<tr class="memdesc:a4b8824833e1d3cc3f5badaf1ff7f4f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overlap a given filter with the current filter creating a higher order filter.  <a href="#a4b8824833e1d3cc3f5badaf1ff7f4f98">More...</a><br/></td></tr>
<tr class="separator:a4b8824833e1d3cc3f5badaf1ff7f4f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective scheduling handles</div></td></tr>
<tr class="memitem:ad3e03d029cd70d548e94e5cf1ee20f00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_schedule.html">RecFilterSchedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ad3e03d029cd70d548e94e5cf1ee20f00">intra_schedule</a> (int id=0)</td></tr>
<tr class="memdesc:ad3e03d029cd70d548e94e5cf1ee20f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a handle to schedule intra-tile functions of the tiled filter.  <a href="#ad3e03d029cd70d548e94e5cf1ee20f00">More...</a><br/></td></tr>
<tr class="separator:ad3e03d029cd70d548e94e5cf1ee20f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03b834571ec68b52e0ea9091d2fdbba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_schedule.html">RecFilterSchedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#af03b834571ec68b52e0ea9091d2fdbba">inter_schedule</a> (void)</td></tr>
<tr class="memdesc:af03b834571ec68b52e0ea9091d2fdbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a handle to schedule intra-tile functions of the tiled filter.  <a href="#af03b834571ec68b52e0ea9091d2fdbba">More...</a><br/></td></tr>
<tr class="separator:af03b834571ec68b52e0ea9091d2fdbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fba7d2b1aaa2124df1b3e05cebfa7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rec_filter_schedule.html">RecFilterSchedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a42fba7d2b1aaa2124df1b3e05cebfa7e">full_schedule</a> (void)</td></tr>
<tr class="memdesc:a42fba7d2b1aaa2124df1b3e05cebfa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a handle to schedule non-tiled filter.  <a href="#a42fba7d2b1aaa2124df1b3e05cebfa7e">More...</a><br/></td></tr>
<tr class="separator:a42fba7d2b1aaa2124df1b3e05cebfa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8047dc496a564fc2b4b8eafa9e994c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a8047dc496a564fc2b4b8eafa9e994c2b">compute_at</a> (<a class="el" href="class_rec_filter.html">RecFilter</a> external)</td></tr>
<tr class="memdesc:a8047dc496a564fc2b4b8eafa9e994c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set final result of filter to be computed at an external recursive filter, useful for merging the filter with external stages; the filter must not depend upon the external function.  <a href="#a8047dc496a564fc2b4b8eafa9e994c2b">More...</a><br/></td></tr>
<tr class="separator:a8047dc496a564fc2b4b8eafa9e994c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d7257972c8d9d9cdb4d111f1bf0936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a34d7257972c8d9d9cdb4d111f1bf0936">compute_at</a> (Halide::Func external, Halide::Var granularity)</td></tr>
<tr class="memdesc:a34d7257972c8d9d9cdb4d111f1bf0936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set final result of filter to be computed at an external Func, useful for merging the filter with external stages; the filter must not depend upon the external function.  <a href="#a34d7257972c8d9d9cdb4d111f1bf0936">More...</a><br/></td></tr>
<tr class="separator:a34d7257972c8d9d9cdb4d111f1bf0936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Automatic scheduling for GPU targets</div></td></tr>
<tr class="memitem:a4a8e6f9042841f05282a7e8babde3c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a4a8e6f9042841f05282a7e8babde3c31">gpu_auto_full_schedule</a> (int max_threads, int tile_width=32)</td></tr>
<tr class="memdesc:a4a8e6f9042841f05282a7e8babde3c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic GPU schedule for non-tiled filter and return a handle for additional scheduling.  <a href="#a4a8e6f9042841f05282a7e8babde3c31">More...</a><br/></td></tr>
<tr class="separator:a4a8e6f9042841f05282a7e8babde3c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9839f98ff878ef3810fef6e6a4f809b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a9839f98ff878ef3810fef6e6a4f809b5">gpu_auto_schedule</a> (int max_threads, int tile_width=32)</td></tr>
<tr class="memdesc:a9839f98ff878ef3810fef6e6a4f809b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic GPU schedule for tiled or non-tiled recursive filter; calls <a class="el" href="class_rec_filter.html#a4a8e6f9042841f05282a7e8babde3c31" title="Automatic GPU schedule for non-tiled filter and return a handle for additional scheduling. ">RecFilter::gpu_auto_full_schedule()</a>, <a class="el" href="class_rec_filter.html#a0db547c81747a8e34eb343a2fef14c44" title="Automatic GPU schedule for intra-tile functions if tiled filter. ">RecFilter::gpu_auto_intra_schedule()</a> and <a class="el" href="class_rec_filter.html#aea181a818cbfd7295fec84c1e417d240" title="Automatic GPU schedule for inter-tile functions of tiled filter. ">RecFilter::gpu_auto_inter_schedule()</a>.  <a href="#a9839f98ff878ef3810fef6e6a4f809b5">More...</a><br/></td></tr>
<tr class="separator:a9839f98ff878ef3810fef6e6a4f809b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea181a818cbfd7295fec84c1e417d240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#aea181a818cbfd7295fec84c1e417d240">gpu_auto_inter_schedule</a> (int max_threads)</td></tr>
<tr class="memdesc:aea181a818cbfd7295fec84c1e417d240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic GPU schedule for inter-tile functions of tiled filter.  <a href="#aea181a818cbfd7295fec84c1e417d240">More...</a><br/></td></tr>
<tr class="separator:aea181a818cbfd7295fec84c1e417d240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db547c81747a8e34eb343a2fef14c44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a0db547c81747a8e34eb343a2fef14c44">gpu_auto_intra_schedule</a> (int id, int max_threads)</td></tr>
<tr class="memdesc:a0db547c81747a8e34eb343a2fef14c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic GPU schedule for intra-tile functions if tiled filter.  <a href="#a0db547c81747a8e34eb343a2fef14c44">More...</a><br/></td></tr>
<tr class="separator:a0db547c81747a8e34eb343a2fef14c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Automatic scheduling for CPU targets</div></td></tr>
<tr class="memitem:aa7832a39d40fd6ea18ef88f25409e156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#aa7832a39d40fd6ea18ef88f25409e156">cpu_auto_schedule</a> (int vector_width)</td></tr>
<tr class="memdesc:aa7832a39d40fd6ea18ef88f25409e156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic CPU schedule for tiled or non-tiled recursive filter; calls <a class="el" href="class_rec_filter.html#a6b7bbd2c913016654cf78813cf650d5c" title="Automatic CPU schedule for non-tiled filter. ">RecFilter::cpu_auto_full_schedule()</a>, <a class="el" href="class_rec_filter.html#ad89986ef2db44980026d9aebe00d6195" title="Automatic CPU schedule for intra-tile functions if tiled filter. ">RecFilter::cpu_auto_intra_schedule()</a> and <a class="el" href="class_rec_filter.html#ad80da9cc4eea2a434337a7f0cab4df23" title="Automatic CPU schedule for inter-tile functions of tiled filter. ">RecFilter::cpu_auto_inter_schedule()</a>.  <a href="#aa7832a39d40fd6ea18ef88f25409e156">More...</a><br/></td></tr>
<tr class="separator:aa7832a39d40fd6ea18ef88f25409e156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7bbd2c913016654cf78813cf650d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a6b7bbd2c913016654cf78813cf650d5c">cpu_auto_full_schedule</a> (int vector_width)</td></tr>
<tr class="memdesc:a6b7bbd2c913016654cf78813cf650d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic CPU schedule for non-tiled filter.  <a href="#a6b7bbd2c913016654cf78813cf650d5c">More...</a><br/></td></tr>
<tr class="separator:a6b7bbd2c913016654cf78813cf650d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80da9cc4eea2a434337a7f0cab4df23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ad80da9cc4eea2a434337a7f0cab4df23">cpu_auto_inter_schedule</a> (int vector_width)</td></tr>
<tr class="memdesc:ad80da9cc4eea2a434337a7f0cab4df23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic CPU schedule for inter-tile functions of tiled filter.  <a href="#ad80da9cc4eea2a434337a7f0cab4df23">More...</a><br/></td></tr>
<tr class="separator:ad80da9cc4eea2a434337a7f0cab4df23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89986ef2db44980026d9aebe00d6195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ad89986ef2db44980026d9aebe00d6195">cpu_auto_intra_schedule</a> (int vector_width)</td></tr>
<tr class="memdesc:ad89986ef2db44980026d9aebe00d6195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic CPU schedule for intra-tile functions if tiled filter.  <a href="#ad89986ef2db44980026d9aebe00d6195">More...</a><br/></td></tr>
<tr class="separator:ad89986ef2db44980026d9aebe00d6195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generic handles to write schedules for dimensions of internal functions</div></td></tr>
<tr class="memitem:a4bc66354c93fd6f9667ba2dd9926c490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a4bc66354c93fd6f9667ba2dd9926c490">full</a> (int i=-1)</td></tr>
<tr class="separator:a4bc66354c93fd6f9667ba2dd9926c490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9f6d93e1db70ab9818b6ce2da630b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#abd9f6d93e1db70ab9818b6ce2da630b1">inner</a> (int i=-1)</td></tr>
<tr class="separator:abd9f6d93e1db70ab9818b6ce2da630b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0edc546d411857c9d4d2d6dd0287e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a9d0edc546d411857c9d4d2d6dd0287e5">outer</a> (int i=-1)</td></tr>
<tr class="separator:a9d0edc546d411857c9d4d2d6dd0287e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19951c9bcbb3e0caff465f2397c9d613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a19951c9bcbb3e0caff465f2397c9d613">tail</a> (void)</td></tr>
<tr class="separator:a19951c9bcbb3e0caff465f2397c9d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d9289c96fb054e0eb62cd40162c3df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a81d9289c96fb054e0eb62cd40162c3df">full_scan</a> (void)</td></tr>
<tr class="separator:a81d9289c96fb054e0eb62cd40162c3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66abc8b54dfa2d72c721e9630532f2c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a66abc8b54dfa2d72c721e9630532f2c4">inner_scan</a> (void)</td></tr>
<tr class="separator:a66abc8b54dfa2d72c721e9630532f2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8dca85856764a1711eb02a485d6866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a4c8dca85856764a1711eb02a485d6866">outer_scan</a> (void)</td></tr>
<tr class="separator:a4c8dca85856764a1711eb02a485d6866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1ea0cbdb5a44db11396cfb23534285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a1e1ea0cbdb5a44db11396cfb23534285">inner_channels</a> (void)</td></tr>
<tr class="separator:a1e1ea0cbdb5a44db11396cfb23534285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a3654a931172cbdeda7e78ee467105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_tag.html">VarTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#ad0a3654a931172cbdeda7e78ee467105">outer_channels</a> (void)</td></tr>
<tr class="separator:ad0a3654a931172cbdeda7e78ee467105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Print Halide code for the recursive filter</div></td></tr>
<tr class="memitem:a18cfbd3c2235dc78e619353d86fce3cd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a18cfbd3c2235dc78e619353d86fce3cd">print_functions</a> (void) const </td></tr>
<tr class="separator:a18cfbd3c2235dc78e619353d86fce3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d15e61cd2ab18c95ac23d4f9b752d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a08d15e61cd2ab18c95ac23d4f9b752d3">print_synopsis</a> (void) const </td></tr>
<tr class="separator:a08d15e61cd2ab18c95ac23d4f9b752d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b6cd9b0b1100a7c58dda9d083e2d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a923b6cd9b0b1100a7c58dda9d083e2d6">print_schedule</a> (void) const </td></tr>
<tr class="separator:a923b6cd9b0b1100a7c58dda9d083e2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b3719f136ad263a62af7fabb148bea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rec_filter.html#a43b3719f136ad263a62af7fabb148bea">print_hl_code</a> (void) const </td></tr>
<tr class="separator:a43b3719f136ad263a62af7fabb148bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Recursive filter class. </p>

<p>Definition at line <a class="el" href="recfilter_8h_source.html#l00092">92</a> of file <a class="el" href="recfilter_8h_source.html">recfilter.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2d81c3ca6573aa168612ea034b0ff1ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RecFilter::RecFilter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a77471b4e462a755d32e5f7e5ea0fa677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter.html">RecFilter</a>&amp; RecFilter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rec_filter.html">RecFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard assignment operator. </p>

</div>
</div>
<a class="anchor" id="a37a0864233f2ff9e93cdaa4062d2956a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RecFilter::name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the filter. </p>

</div>
</div>
<a class="anchor" id="a69bb99a78cf5fa4dfb7fb7ee5900dbbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95eebe7bfb0e8af0b5eef9bd536e2249"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c20deae5c7f60d664550b70618e9360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f0842626edd0ba9035be35e04a0afa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_var.html">RecFilterRefVar</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37b98112eff6cc3c93b2f1004d9d1986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">Halide::Var&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a96f59f79aa1091a29ee9f67baed52212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">Halide::Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Var&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ba6e6d46148edefd02e33568963aa46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">Halide::Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Var&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5aae2992f981e0553a9f8be1a7e69668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Halide::Var &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae00b8eac289bbc5adf5386b7f74590ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">Halide::Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59313113935d135a33c950f2ed08ada0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">Halide::Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1fe922d57eb70495f5612f4041d5926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">Halide::Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Expr&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Expr&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa3b4e91582270d3ab01e3fdbf1dbba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_ref_expr.html">RecFilterRefExpr</a> RecFilter::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Halide::Expr &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afd1fba24eaeb92a5411292858276da0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::define </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_rec_filter_dim.html">RecFilterDim</a> &gt;&#160;</td>
          <td class="paramname"><em>pure_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Halide::Expr &gt;&#160;</td>
          <td class="paramname"><em>pure_def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pure definition to the recursive filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pure_args</td><td>list of pure args </td></tr>
    <tr><td class="paramname">pure_def</td><td>list of expressions to initialize the filter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d3304a7c3cde75cd9816cc8b6b09775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target RecFilter::target </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the compilation target, inferred from HL_JIT_TARGET. </p>

</div>
</div>
<a class="anchor" id="a02d39bba6665e25f820b0cffdaa33512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::apply_bounds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply output domains bounds; this is performed implicitly for tiled filters, but it must be called by the application for non-tiled filters. </p>

</div>
</div>
<a class="anchor" id="a3890b22a739fffd4bb2c6600e62cf9b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::compile_jit </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger JIT compilation for specified hardware-platform target; dumps the generated codegen in human readable HTML format if filename is specified. </p>

</div>
</div>
<a class="anchor" id="ab3b5e225e29c07bd5bd929a316d595db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Realization RecFilter::realize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the filter. </p>
<dl class="section return"><dt>Returns</dt><dd>Realization object that contains all the buffers </dd></dl>

</div>
</div>
<a class="anchor" id="a966478f0506b8b5fab094069b1c9ff74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float RecFilter::profile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Profile the filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td>number of profiling iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>computation time in milliseconds </dd></dl>

</div>
</div>
<a class="anchor" id="a5c2f413766eca7830f430d37ca49028b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::add_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>coeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34b48679f260a209a75bb2e215a44c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::add_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim_and_causality.html">RecFilterDimAndCausality</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>coeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a743a239a5c3668859936751b029bc468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::set_clamped_image_border </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ef5d4af2950d333846fb7ec0802ac63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func RecFilter::as_func </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast the recfilter as a Halide::Func; this returns the function that holds the final result of this filter; useful for extracting the result of this function to use as input to other Halide Func. </p>

</div>
</div>
<a class="anchor" id="a6bd754d0ab969e2a56cd2d6d27c0b6e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func RecFilter::func </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>func_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the constituent function by name, useful for debugging: </p>
<ul>
<li>realize only a particular stage for correctness or profiling</li>
<li>debugging/testing schedules by using Halide's scheduling primitives directly on the function instead of the high level collective scheduling </li>
</ul>

</div>
</div>
<a class="anchor" id="aeacd059770a9578ad0242f5072450cc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::split_all_dimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e4e6144a8ca33c281ddb9b1afedc57e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a26a0ae3a383f221db2b20bb6c5055edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f92df46549b11e387cfa2e19cdb1da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rec_filter_dim.html">RecFilterDim</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f6a9ed94a44eb190ec8f8fcb989f5c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::split </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, int &gt;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a014f6e2309aee9827237495bd977cc78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_rec_filter.html">RecFilter</a>&gt; RecFilter::cascade </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cascade the filter to produce multiple filters using list of list of scans and producing a list of recursive filters each ccomputes the corresponding list of scans in an overlapped fashion. </p>
<p>Preconditions:</p>
<ul>
<li>filter must not be tiled</li>
<li>list of list of scans spans all the scans of the original filter</li>
<li>no scan is repeated in the list of list of scans</li>
<li>the relative order of scans with respect to causality remains preserved</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>list of scans for first filter </td></tr>
    <tr><td class="paramname">b</td><td>list of scans for second filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>two cascaded filters </dd></dl>

</div>
</div>
<a class="anchor" id="a4be1a6cfe13f5792d68cb16b13406f5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_rec_filter.html">RecFilter</a>&gt; RecFilter::cascade </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cascade the filter to produce multiple filters using list of list of scans and producing a list of recursive filters each ccomputes the corresponding list of scans in an overlapped fashion. </p>
<p>Preconditions:</p>
<ul>
<li>filter must not be tiled</li>
<li>list of list of scans spans all the scans of the original filter</li>
<li>no scan is repeated in the list of list of scans</li>
<li>the relative order of scans with respect to causality remains preserved</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>list of list of scans, each inner list becomes a separate filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of cascaded filters </dd></dl>

</div>
</div>
<a class="anchor" id="a40c96660f146b3cea43385a343dc3408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_rec_filter.html">RecFilter</a>&gt; RecFilter::cascade_by_causality </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computing all causal scans in all dimensions in an overlapped fashion and all anticausal scans in an overlapped fashion and cascade the two groups. </p>
<p>Preconditions:</p>
<ul>
<li>filter must not be tiled</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>list of cascaded filters </dd></dl>

</div>
</div>
<a class="anchor" id="ac0ee44f54ea0788f74a1ce839701bc17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_rec_filter.html">RecFilter</a>&gt; RecFilter::cascade_by_dimension </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all scans in the same dimension in an overlapped fashion and cascade different dimensions. </p>
<p>Preconditions:</p>
<ul>
<li>filter must not be tiled</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>list of cascaded filters </dd></dl>

</div>
</div>
<a class="anchor" id="a4b8824833e1d3cc3f5badaf1ff7f4f98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter.html">RecFilter</a> RecFilter::overlap_to_higher_order_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter.html">RecFilter</a>&#160;</td>
          <td class="paramname"><em>fA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;O&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overlap a given filter with the current filter creating a higher order filter. </p>
<p>Preconditions:</p>
<ul>
<li>filter must not be tiled</li>
<li>given filter must have same number of dimensions in the same order</li>
<li>each scan of each dimension of given filter must have same causality</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>This function is only partially tested and may be unstable</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fA</td><td>filter to be overlapped with current filter </td></tr>
    <tr><td class="paramname">name</td><td>name of the overlapped filter (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>overlapped computation of all scans in both filters </dd></dl>

</div>
</div>
<a class="anchor" id="ad3e03d029cd70d548e94e5cf1ee20f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_schedule.html">RecFilterSchedule</a> RecFilter::intra_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a handle to schedule intra-tile functions of the tiled filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>0 for all intra tile functions, 1 for nD intra-tile functions, otherwise 1D intra-tile functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af03b834571ec68b52e0ea9091d2fdbba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_schedule.html">RecFilterSchedule</a> RecFilter::inter_schedule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a handle to schedule intra-tile functions of the tiled filter. </p>

</div>
</div>
<a class="anchor" id="a42fba7d2b1aaa2124df1b3e05cebfa7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rec_filter_schedule.html">RecFilterSchedule</a> RecFilter::full_schedule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a handle to schedule non-tiled filter. </p>

</div>
</div>
<a class="anchor" id="a8047dc496a564fc2b4b8eafa9e994c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::compute_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rec_filter.html">RecFilter</a>&#160;</td>
          <td class="paramname"><em>external</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set final result of filter to be computed at an external recursive filter, useful for merging the filter with external stages; the filter must not depend upon the external function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">external</td><td>function inside which the filter must be computed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34d7257972c8d9d9cdb4d111f1bf0936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::compute_at </td>
          <td>(</td>
          <td class="paramtype">Halide::Func&#160;</td>
          <td class="paramname"><em>external</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Var&#160;</td>
          <td class="paramname"><em>granularity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set final result of filter to be computed at an external Func, useful for merging the filter with external stages; the filter must not depend upon the external function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">external</td><td>function inside which the filter must be computed </td></tr>
    <tr><td class="paramname">granularity</td><td>variable where this filter's result should be computed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a8e6f9042841f05282a7e8babde3c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::gpu_auto_full_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tile_width</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic GPU schedule for non-tiled filter and return a handle for additional scheduling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_threads</td><td>maximum threads in a CUDA warp </td></tr>
    <tr><td class="paramname">tile_width</td><td>tiling factor to split non-tiled dimensions into CUDA blocks and CUDA tiles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9839f98ff878ef3810fef6e6a4f809b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::gpu_auto_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tile_width</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic GPU schedule for tiled or non-tiled recursive filter; calls <a class="el" href="class_rec_filter.html#a4a8e6f9042841f05282a7e8babde3c31" title="Automatic GPU schedule for non-tiled filter and return a handle for additional scheduling. ">RecFilter::gpu_auto_full_schedule()</a>, <a class="el" href="class_rec_filter.html#a0db547c81747a8e34eb343a2fef14c44" title="Automatic GPU schedule for intra-tile functions if tiled filter. ">RecFilter::gpu_auto_intra_schedule()</a> and <a class="el" href="class_rec_filter.html#aea181a818cbfd7295fec84c1e417d240" title="Automatic GPU schedule for inter-tile functions of tiled filter. ">RecFilter::gpu_auto_inter_schedule()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_threads</td><td>maximum threads in a CUDA warp </td></tr>
    <tr><td class="paramname">tile_width</td><td>tiling factor to non-tiled full dimensions into CUDA blocks and CUDA tiles (only used if filter is not tiled) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea181a818cbfd7295fec84c1e417d240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::gpu_auto_inter_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic GPU schedule for inter-tile functions of tiled filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_threads</td><td>maximum threads in a CUDA warp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0db547c81747a8e34eb343a2fef14c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::gpu_auto_intra_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic GPU schedule for intra-tile functions if tiled filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>0 for all intra tile functions, 1 for nD intra-tile functions, otherwise 1D intra-tile functions </td></tr>
    <tr><td class="paramname">max_threads</td><td>maximum threads in a CUDA warp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7832a39d40fd6ea18ef88f25409e156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::cpu_auto_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vector_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic CPU schedule for tiled or non-tiled recursive filter; calls <a class="el" href="class_rec_filter.html#a6b7bbd2c913016654cf78813cf650d5c" title="Automatic CPU schedule for non-tiled filter. ">RecFilter::cpu_auto_full_schedule()</a>, <a class="el" href="class_rec_filter.html#ad89986ef2db44980026d9aebe00d6195" title="Automatic CPU schedule for intra-tile functions if tiled filter. ">RecFilter::cpu_auto_intra_schedule()</a> and <a class="el" href="class_rec_filter.html#ad80da9cc4eea2a434337a7f0cab4df23" title="Automatic CPU schedule for inter-tile functions of tiled filter. ">RecFilter::cpu_auto_inter_schedule()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_width</td><td>vectorization width of the target platform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b7bbd2c913016654cf78813cf650d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::cpu_auto_full_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vector_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic CPU schedule for non-tiled filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_width</td><td>vectorization width of the target platform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad80da9cc4eea2a434337a7f0cab4df23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::cpu_auto_inter_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vector_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic CPU schedule for inter-tile functions of tiled filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_width</td><td>vectorization width of the target platform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad89986ef2db44980026d9aebe00d6195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecFilter::cpu_auto_intra_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vector_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatic CPU schedule for intra-tile functions if tiled filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_width</td><td>vectorization width of the target platform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bc66354c93fd6f9667ba2dd9926c490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::full </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abd9f6d93e1db70ab9818b6ce2da630b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::inner </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d0edc546d411857c9d4d2d6dd0287e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::outer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19951c9bcbb3e0caff465f2397c9d613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::tail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81d9289c96fb054e0eb62cd40162c3df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::full_scan </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66abc8b54dfa2d72c721e9630532f2c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::inner_scan </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c8dca85856764a1711eb02a485d6866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::outer_scan </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e1ea0cbdb5a44db11396cfb23534285"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::inner_channels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0a3654a931172cbdeda7e78ee467105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_tag.html">VarTag</a> RecFilter::outer_channels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18cfbd3c2235dc78e619353d86fce3cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RecFilter::print_functions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a08d15e61cd2ab18c95ac23d4f9b752d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RecFilter::print_synopsis </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a923b6cd9b0b1100a7c58dda9d083e2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RecFilter::print_schedule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43b3719f136ad263a62af7fabb148bea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RecFilter::print_hl_code </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/<a class="el" href="recfilter_8h_source.html">recfilter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_rec_filter.html">RecFilter</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
